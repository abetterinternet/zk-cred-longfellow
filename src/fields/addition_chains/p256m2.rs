// Code generated by addchain. Do not edit.

use crate::fields::FieldElement;

/// Exponentiates a field element to a constant power.
///
/// This is used to either exponentiate field elements to the power (|F| - 2), in order to compute
/// multiplicative inverses in constant time, or to the power (p + 1) / 4, in order to compute
/// square roots in certain fields in constant time.
#[allow(unused_mut)]
pub(crate) fn exp<F: FieldElement>(x: F) -> F {
    // This is implemented with addition chain exponentiation, using the following chain:
    //
    //   _10     = 2*1
    //   _11     = 1 + _10
    //   _110    = 2*_11
    //   _111    = 1 + _110
    //   _111000 = _111 << 3
    //   _111111 = _111 + _111000
    //   x12     = _111111 << 6 + _111111
    //   x15     = x12 << 3 + _111
    //   x16     = 2*x15 + 1
    //   x32     = x16 << 16 + x16
    //   i53     = x32 << 15
    //   x47     = x15 + i53
    //   i263    = ((i53 << 17 + 1) << 143 + x47) << 47
    //   return    (x47 + i263) << 2 + 1
    //
    // Operations: 255 squares and 12 multiplications.
    //
    // Generated by github.com/mmcloughlin/addchain v0.4.0.

    let mut t0;
    let mut t1;
    let mut t2;
    let mut z;

    // Step 1: t0 = x^0x2
    t0 = x.square();

    // Step 2: t0 = x^0x3
    t0 = x * t0;

    // Step 3: t0 = x^0x6
    t0 = t0.square();

    // Step 4: t0 = x^0x7
    t0 = x * t0;

    // Step 7: t1 = x^0x38
    t1 = t0.square();
    for _ in 1..3 {
        t1 = t1.square();
    }

    // Step 8: t1 = x^0x3f
    t1 = t0 * t1;

    // Step 14: t2 = x^0xfc0
    t2 = t1.square();
    for _ in 1..6 {
        t2 = t2.square();
    }

    // Step 15: t1 = x^0xfff
    t1 *= t2;

    // Step 18: t1 = x^0x7ff8
    for _ in 0..3 {
        t1 = t1.square();
    }

    // Step 19: t0 = x^0x7fff
    t0 *= t1;

    // Step 20: t1 = x^0xfffe
    t1 = t0.square();

    // Step 21: t1 = x^0xffff
    t1 = x * t1;

    // Step 37: t2 = x^0xffff0000
    t2 = t1.square();
    for _ in 1..16 {
        t2 = t2.square();
    }

    // Step 38: t1 = x^0xffffffff
    t1 *= t2;

    // Step 53: t1 = x^0x7fffffff8000
    for _ in 0..15 {
        t1 = t1.square();
    }

    // Step 54: t0 = x^0x7fffffffffff
    t0 *= t1;

    // Step 71: t1 = x^0xffffffff00000000
    for _ in 0..17 {
        t1 = t1.square();
    }

    // Step 72: t1 = x^0xffffffff00000001
    t1 = x * t1;

    // Step 215: t1 = x^0x7fffffff80000000800000000000000000000000000000000000
    for _ in 0..143 {
        t1 = t1.square();
    }

    // Step 216: t1 = x^0x7fffffff800000008000000000000000000000007fffffffffff
    t1 = t0 * t1;

    // Step 263: t1 = x^0x3fffffffc00000004000000000000000000000003fffffffffff800000000000
    for _ in 0..47 {
        t1 = t1.square();
    }

    // Step 264: t0 = x^0x3fffffffc00000004000000000000000000000003fffffffffffffffffffffff
    t0 *= t1;

    // Step 266: t0 = x^0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
    for _ in 0..2 {
        t0 = t0.square();
    }

    // Step 267: z = x^0xffffffff00000001000000000000000000000000fffffffffffffffffffffffd
    z = x * t0;

    z
}
