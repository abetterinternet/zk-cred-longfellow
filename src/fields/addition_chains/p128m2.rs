// Code generated by addchain. Do not edit.

use crate::fields::FieldElement;

/// Exponentiates a field element to a constant power.
///
/// This is used to either exponentiate field elements to the power (|F| - 2), in order to compute
/// multiplicative inverses in constant time, or to the power (p + 1) / 4, in order to compute
/// square roots in certain fields in constant time.
#[allow(unused_mut)]
pub(crate) fn exp<F: FieldElement>(x: F) -> F {
    // This is implemented with addition chain exponentiation, using the following chain:
    //
    //   _10      = 2*1
    //   _11      = 1 + _10
    //   _110     = 2*_11
    //   _111     = 1 + _110
    //   _111000  = _111 << 3
    //   _111111  = _111 + _111000
    //   _1111110 = 2*_111111
    //   x13      = _1111110 << 6 + _1111110 + 1
    //   x19      = x13 << 6 + _111111
    //   i30      = x19 << 6
    //   i37      = i30 << 7
    //   i56      = i37 << 19
    //   i57      = i37 + i56
    //   i136     = ((i56 << 20 + i57) << 12 + i30) << 45
    //   return     i57 + i136 + x13
    //
    // Operations: 127 squares and 11 multiplications.
    //
    // Generated by github.com/mmcloughlin/addchain v0.4.0.

    let mut t0;
    let mut t1;
    let mut t2;
    let mut z;

    // Step 1: t0 = x^0x2
    t0 = x.square();

    // Step 2: t0 = x^0x3
    t0 = x * t0;

    // Step 3: t0 = x^0x6
    t0 = t0.square();

    // Step 4: t0 = x^0x7
    t0 = x * t0;

    // Step 7: t1 = x^0x38
    t1 = t0.square();
    for _ in 1..3 {
        t1 = t1.square();
    }

    // Step 8: t0 = x^0x3f
    t0 *= t1;

    // Step 9: t1 = x^0x7e
    t1 = t0.square();

    // Step 15: t2 = x^0x1f80
    t2 = t1.square();
    for _ in 1..6 {
        t2 = t2.square();
    }

    // Step 16: t1 = x^0x1ffe
    t1 *= t2;

    // Step 17: z = x^0x1fff
    z = x * t1;

    // Step 23: t1 = x^0x7ffc0
    t1 = z.square();
    for _ in 1..6 {
        t1 = t1.square();
    }

    // Step 24: t0 = x^0x7ffff
    t0 *= t1;

    // Step 30: t0 = x^0x1ffffc0
    for _ in 0..6 {
        t0 = t0.square();
    }

    // Step 37: t1 = x^0xffffe000
    t1 = t0.square();
    for _ in 1..7 {
        t1 = t1.square();
    }

    // Step 56: t2 = x^0x7ffff00000000
    t2 = t1.square();
    for _ in 1..19 {
        t2 = t2.square();
    }

    // Step 57: t1 = x^0x7ffffffffe000
    t1 *= t2;

    // Step 77: t2 = x^0x7ffff0000000000000
    for _ in 0..20 {
        t2 = t2.square();
    }

    // Step 78: t2 = x^0x7ffff7ffffffffe000
    t2 = t1 * t2;

    // Step 90: t2 = x^0x7ffff7ffffffffe000000
    for _ in 0..12 {
        t2 = t2.square();
    }

    // Step 91: t0 = x^0x7ffff7fffffffffffffc0
    t0 *= t2;

    // Step 136: t0 = x^0xffffeffffffffffffff8000000000000
    for _ in 0..45 {
        t0 = t0.square();
    }

    // Step 137: t1 = x^0xffffefffffffffffffffffffffffe000
    t1 *= t0;

    // Step 138: z = x^0xffffefffffffffffffffffffffffffff
    z *= t1;

    z
}
