use crate::{
    Codec, Size,
    fields::{CodecFieldElement, FieldId},
};
use anyhow::{Context, anyhow};
use educe::Educe;
use std::{
    collections::HashSet,
    fmt::{self, Formatter},
    io::{Cursor, Read},
};

/// A circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, PartialEq, Eq, Educe)]
#[educe(Debug)]
pub struct Circuit<FE> {
    /// 1 byte version. Currently always 1.
    version: u8,
    /// The field this circuit uses. (not clear what subfield is used; hard coded to P256?)
    field: FieldId,
    /// Number of output wires (also `nv` in some places).
    num_outputs: usize,
    /// Number of copies (what's a copy? is this used?)
    num_copies: usize,
    /// Number of public inputs.
    num_public_inputs: usize,
    /// Least input wire not known to be in the subfield (what's the subfield though?)
    subfield_boundary: usize,
    /// Number of inputs, including witnesses. Always >= num_public_inputs, which is the index of
    /// of the first private input.
    num_inputs: usize,
    /// Number of layers in the circuit.
    num_layers: usize,
    /// Array of constants pointed to by the circuit's quads.
    pub(crate) constant_table: Vec<FE>,
    /// The layers of the circuit. There are num_layers of these, so this gets serialized as a fixed
    /// length array.
    pub(crate) layers: Vec<CircuitLayer>,
    /// 32 byte identifier for the circuit. Generated by the circuit compiler.
    #[educe(Debug(method(fmt_id)))]
    pub(crate) id: [u8; 32],
}

fn fmt_id(s: &[u8; 32], f: &mut Formatter<'_>) -> fmt::Result {
    f.write_str(hex::encode(s).as_str())
}

impl<FE: CodecFieldElement> Codec for Circuit<FE> {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let version = u8::decode(bytes)?;
        let field = FieldId::decode(bytes)?;
        let num_outputs = Size::decode(bytes)?.try_into()?;
        let num_copies = Size::decode(bytes)?.try_into()?;
        let num_public_inputs = Size::decode(bytes)?.try_into()?;
        let subfield_boundary = Size::decode(bytes)?.try_into()?;
        let num_inputs = Size::decode(bytes)?.try_into()?;
        let num_layers = Size::decode(bytes)?.try_into()?;
        let num_constants = Size::decode(bytes)?.try_into()?;

        // Decode constant table: first a count of elements, then each element's length is obtained
        // from the field ID.
        let mut constant_table = Vec::with_capacity(num_constants);
        for _ in 0..num_constants.into() {
            constant_table.push(FE::decode(bytes)?);
        }

        let layers = CircuitLayer::decode_fixed_array(bytes, num_layers)
            .context("failed to decode layers")?;
        let mut id = [0u8; 32];
        bytes
            .read_exact(&mut id)
            .context("failed to read 32 bytes of circuit ID")?;

        Ok(Self {
            version,
            field,
            num_outputs,
            num_copies,
            num_public_inputs,
            subfield_boundary,
            num_inputs,
            num_layers,
            constant_table,
            layers,
            id,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.version.encode(bytes)?;
        self.field.encode(bytes)?;
        Size::try_from(self.num_outputs)?.encode(bytes)?;
        Size::try_from(self.num_copies)?.encode(bytes)?;
        Size::try_from(self.num_public_inputs)?.encode(bytes)?;
        Size::try_from(self.subfield_boundary)?.encode(bytes)?;
        Size::try_from(self.num_inputs)?.encode(bytes)?;
        Size::try_from(self.num_layers)?.encode(bytes)?;

        FE::encode_array(&self.constant_table, bytes)?;
        if self.num_layers() != self.layers.len() {
            return Err(anyhow!("num_layers does not match length of layers array"));
        }
        CircuitLayer::encode_fixed_array(&self.layers, bytes)?;
        bytes.extend_from_slice(&self.id);

        Ok(())
    }
}

impl<FE: CodecFieldElement> Circuit<FE> {
    /// The number of bits needed to describe an output wire. Analogous to `Layer::logw`.
    pub fn logw(&self) -> usize {
        // Unwrap safety: usize should be bigger than u32 anywhere we run
        self.num_outputs
            .next_power_of_two()
            .ilog2()
            .try_into()
            .expect("u32 too big for usize?")
    }

    /// Retrieve the requested constant from the circuit's constant table, if it exists.
    pub fn constant(&self, index: usize) -> Result<FE, anyhow::Error> {
        self.constant_table
            .get(index)
            .map(|c| *c)
            .ok_or_else(|| anyhow!("index {} not present in constant table", index))
    }

    /// Identifier for the field this circuit uses.
    pub fn field_id(&self) -> FieldId {
        self.field
    }

    /// Number of copies in the circuit (always 1).
    pub fn num_copies(&self) -> usize {
        self.num_copies
    }

    /// Retrieve the circuit's constant table, decoded into field elements.
    pub fn constants(&self) -> &[FE] {
        &self.constant_table
    }

    /// The number of quads (aka terms?) in this circuit.
    pub fn num_quads(&self) -> usize {
        self.layers.iter().map(|layer| layer.quads.len()).sum()
    }

    /// The number of layers in this circuit.
    pub fn num_layers(&self) -> usize {
        self.num_layers
    }

    /// The sum of each layer's logw.
    pub fn logw_sum(&self) -> usize {
        self.layers.iter().map(CircuitLayer::logw).sum()
    }

    /// The number of inputs to the circuit.
    pub fn num_inputs(&self) -> usize {
        self.num_inputs
    }

    /// The number of public inputs to the circuit.
    pub fn num_public_inputs(&self) -> usize {
        self.num_public_inputs
    }

    /// The number of private inputs to the circuit.
    pub fn num_private_inputs(&self) -> usize {
        self.num_inputs - self.num_public_inputs()
    }

    /// The number of outputs from the ciruit.
    pub fn num_outputs(&self) -> usize {
        self.num_outputs
    }

    /// Evaluate the circuit with the provided inputs.
    pub fn evaluate(&self, inputs: &[FE]) -> Result<Evaluation<FE>, anyhow::Error> {
        // There are n layers of gates, but with the inputs, we have n + 1 layers of wires.
        let mut wires = Vec::with_capacity(self.layers.len() + 1);

        // "By convention, the input wire Vj[0] = 1 for all layers, and thus the quad representation
        // handles the classic add and multiplication gates in a uniform manner."
        // This is because we represent constants in the circuit by multiplying the input 1 by
        // whatever the value we need. We apply this fixup only for the first layer, as subsequent
        // layers are constructed to propagate the constant 1.
        //
        // https://eprint.iacr.org/2024/2010.pdf, section 2.1
        wires.push([&[FE::ONE], inputs].concat());

        // We are iterating over layers in reverse, so the output layer is at the end of the
        // iterator
        let output_layer_index = self.num_layers() - 1;
        for (layer_index, layer) in self
            .layers
            .iter()
            // In the serialized format, the input layer comes last, so reverse the layers iterator.
            .rev()
            .enumerate()
        {
            let next_layer_num_wires = if layer_index == output_layer_index {
                self.num_outputs()
            } else {
                self.layers[
                    // index from the end because we are iterating self.layers in reverse
                    output_layer_index - layer_index
                    // next layer of the circuit is -1
                    - 1
                ]
                .num_wires()
            };
            // A single gate may receive contributions from multiple quads, so preallocate a vector
            // of length matching the next layer's number of input wires, and accumulate quad
            // outputs into that.
            // Depending on the circuit compiler, it's possible that there will be unused elements
            // in this vector.
            let mut gate_outputs = vec![FE::ZERO; next_layer_num_wires];

            // Note which gates receive contributions from Z quads.
            let mut z_gate_indexes = HashSet::new();

            for (quad_index, quad) in layer.quads.iter().enumerate() {
                // Evaluate this quad: look up its value in the constants table, then multiply that
                // by the value of the input wires.
                let quad_value: FE = self.constant(quad.const_table_index()).context(format!(
                    "constant missing in quad {quad_index} on layer {layer_index}"
                ))?;

                let left_wire = wires[layer_index].get(quad.left_wire_index()).ok_or_else(
                    || {
                        anyhow!(
                            "quad {quad_index} on layer {layer_index} contains left wire index {} \
                            not present in previous layer of circuit {:?}",
                            quad.left_wire_index,
                            wires[layer_index],
                        )
                    },
                )?;
                let right_wire = wires[layer_index].get(quad.right_wire_index()).ok_or_else(
                    || {
                        anyhow!(
                            "quad {quad_index} on layer {layer_index} contains right wire index {} \
                            not present in previous layer of circuit {:?}",
                            quad.right_wire_index,
                            wires[layer_index],
                        )
                    },
                )?;

                let quad_output = if quad_value.is_zero().into() {
                    z_gate_indexes.insert(quad.gate_index());

                    *left_wire * right_wire
                } else {
                    quad_value * left_wire * right_wire
                };

                // Specification interpretation verification: this should never happen. We check
                // this condition in roundtrip_circuit_test_vector, but not in deserialization.
                if quad.gate_index() >= next_layer_num_wires {
                    panic!(
                        "quad {quad_index} on layer {layer_index} contains gate index {} exceeding \
                        the next layer's number of input wires {next_layer_num_wires}",
                        quad.gate_index,
                    )
                }
                gate_outputs[quad.gate_index()] += quad_output;
            }

            // Specification interpretation verification: check that gates which received input from
            // Z quads output zero. This has to be true since (1) all Z quads output zero and (2) we
            // expect that Q and Z are disjoint. We verify the latter in
            // roundtrip_circuit_test_vector.
            for gate_index in z_gate_indexes {
                if !bool::from(gate_outputs[gate_index].is_zero()) {
                    return Err(anyhow!(
                        "in-circuit assertion failed at layer {layer_index}, gate {gate_index}"
                    ));
                }
            }

            wires.push(gate_outputs);
        }

        // Reverse wires so that the inputs come last and the outputs come first.
        wires.reverse();
        Ok(Evaluation { wires })
    }

    /// Compute the combined quad `QZ = Q + beta * Z` for the specified layer.
    ///
    /// Because Q and Z are disjoint, this amounts to traversing the layer's quads, identifying Z
    /// quads (the ones whose value is zero) and setting their value to beta. This is then compiled
    /// into a three-dimensional array indexed by gate index, left wire index, and right wire index.
    pub fn combined_quad(
        &self,
        layer_index: usize,
        beta: FE,
    ) -> Result<Vec<Vec<Vec<FE>>>, anyhow::Error> {
        // The number of gates on this layer is the number of input wires to the next layer
        let num_gates = if layer_index == 0 {
            self.num_outputs()
        } else {
            self.layers[layer_index - 1].num_wires()
        };

        // Outer vector: index by gate number
        let mut combined_quad = vec![
            // Inner vector: index by left wire number
            vec![
                // Innermost vector: index by right wire number
                vec![FE::ZERO; self.layers[layer_index].num_wires()];
                self.layers[layer_index].num_wires()
            ];
            num_gates
        ];

        for quad in &self.layers[layer_index].quads {
            let quad_value: FE = self.constant(quad.const_table_index())?;

            combined_quad[quad.gate_index()][quad.left_wire_index()][quad.right_wire_index()] =
                if quad_value.is_zero().into() {
                    beta
                } else {
                    quad_value
                };
        }

        Ok(combined_quad)
    }
}

/// The evaluation of a circuit.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Evaluation<FieldElement> {
    /// The value of each of the wires of the circuit after evaluation. An n-layer circuit has n+1
    /// layers of wire values. Layer index 0 is the outputs and layer index n is the inputs. The
    /// length of each layer depends on the number of gates on each layer.
    pub wires: Vec<Vec<FieldElement>>,
}

impl<FieldElement> Evaluation<FieldElement> {
    /// Get the outputs of this evaluation.
    pub fn outputs(&self) -> &[FieldElement] {
        self.wires[0].as_slice()
    }

    /// Get the public inputs for this evaluation.
    pub fn public_inputs(&self, num_public_inputs: usize) -> &[FieldElement] {
        &self.inputs()[..num_public_inputs]
    }

    /// Get the private inputs for this evaluation.
    pub fn private_inputs(&self, num_public_inputs: usize) -> &[FieldElement] {
        &self.inputs()[num_public_inputs..]
    }

    pub fn inputs(&self) -> &[FieldElement] {
        &self.wires[self.wires.len() - 1]
    }
}

/// A layer of a circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, Educe, PartialEq, Eq)]
#[educe(Debug)]
pub struct CircuitLayer {
    /// This is the number of bits needed to name a wire on this layer ([1]). Thus, it's usually
    /// `ceil(log_2(num_wires))`, but apparently not always. The value of output wire i is 0 for
    /// `i >= 2^logw`, because there are no such wires at this layer.
    ///
    /// [1]: https://www.ietf.org/archive/id/draft-google-cfrg-libzk-00.html#section-5.3.2
    ///
    /// Longfellow calls this "number of binding rounds for the hand variables".
    pub(crate) logw: Size,
    /// Number of wires entering the layer, hence the number of inputs.
    pub(crate) num_wires: Size,
    /// Quads describing this layer of the circuit. A variable length array.
    ///
    /// [5.3.3.][1] discusses the combined circuit QZ = Q + beta * Z for some random beta. beta is
    /// chosen during proof generation, and so is not serialized. However the combined quad does
    /// impact the serialization format: because Q and Z are disjoint matrices, then any quad whose
    /// value is nonzero is understood to be part of Q, and any quad whose value is zero is
    /// understood to be part of Z.
    ///
    /// [1]: https://www.ietf.org/archive/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    pub(crate) quads: Vec<Quad>,
}

impl Codec for CircuitLayer {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let logw = Size::decode(bytes)?;
        let num_wires = Size::decode(bytes)?;
        let num_quads = Size::decode(bytes)?;

        let mut prev_quad = None;
        let mut quads = Vec::with_capacity(num_quads.into());
        for _ in 0..num_quads.0 {
            let quad = Quad::decode(prev_quad, bytes)?;
            prev_quad = Some(quad);
            quads.push(quad);
        }

        Ok(Self {
            logw,
            num_wires,
            quads,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.logw.encode(bytes)?;
        self.num_wires.encode(bytes)?;
        Size::from(self.quads.len() as u32).encode(bytes)?;

        let mut prev_quad = None;
        for quad in &self.quads {
            quad.encode(prev_quad, bytes)?;
            prev_quad = Some(*quad);
        }

        Ok(())
    }
}

impl CircuitLayer {
    /// The number of bits needed to describe a wire on this layer.
    pub fn logw(&self) -> usize {
        self.logw.into()
    }

    /// Number of wires entering the layer, hence the number of inputs.
    pub fn num_wires(&self) -> usize {
        self.num_wires.into()
    }
}

/// A quad describes an individual gate in the circuit, serialized according to struct Quad in [1]
/// and the ad-hoc definition in [2] and [3].
///
/// [2] and [3] implement a `struct Quad` which in turn contains a vector of `Quad::corner`. Each
/// `corner` value corresponds to the draft's `struct Quad`.
///
/// [1]: https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-00#section-7.6
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [3]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/quad.h
#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]
pub struct Quad {
    gate_index: usize,
    left_wire_index: usize,
    right_wire_index: usize,
    const_table_index: usize,
}

impl Quad {
    /// Encode this quad as deltas relative to the previous quad in the circuit.
    // XXX extend [`crate::Codec`] to take an encoding parameter like prio::codec does so we can
    // pass in prev_quad
    fn encode(&self, prev_quad: Option<Quad>, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        Size::try_from(self.gate_index)?.encode_delta(prev_quad.gate_index.try_into()?, bytes)?;
        Size::try_from(self.left_wire_index)?
            .encode_delta(prev_quad.left_wire_index.try_into()?, bytes)?;
        Size::try_from(self.right_wire_index)?
            .encode_delta(prev_quad.right_wire_index.try_into()?, bytes)?;
        Size::try_from(self.const_table_index)?.encode(bytes)?;

        Ok(())
    }

    /// Encode this quad as deltas relative to the previous quad in the circuit.
    fn decode(prev_quad: Option<Quad>, bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        let gate_index = Size::decode_delta(prev_quad.gate_index.try_into()?, bytes)?.try_into()?;
        let left_wire_index =
            Size::decode_delta(prev_quad.left_wire_index.try_into()?, bytes)?.try_into()?;
        let right_wire_index =
            Size::decode_delta(prev_quad.right_wire_index.try_into()?, bytes)?.try_into()?;
        let const_table_index = Size::decode(bytes)?.try_into()?;

        Ok(Self {
            gate_index,
            left_wire_index,
            right_wire_index,
            const_table_index,
        })
    }

    /// The position of ths gate in its layer, corresponding to `gate_number` in the specification.
    fn gate_index(&self) -> usize {
        self.gate_index
    }

    /// Index of the left-hand wire feeding into this gate.
    fn left_wire_index(&self) -> usize {
        self.left_wire_index
    }

    /// Index of the right-hand wire feeding into this gate.
    fn right_wire_index(&self) -> usize {
        self.right_wire_index
    }

    /// Index into the circuit's constant table. The value at that index is the quad's value. If the
    /// value is 0, the quad is part of Z. If the value is nonzero, the quad is part of Q. See [1]
    /// for discussion of the combined quad.
    ///
    /// [1]: https://www.ietf.org/archive/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    fn const_table_index(&self) -> usize {
        self.const_table_index
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use crate::{
        Codec, Size,
        circuit::{Circuit, CircuitLayer, Evaluation, Quad},
        fields::{
            CodecFieldElement, FieldElement, FieldId, field2_128::Field2_128, fieldp128::FieldP128,
        },
        test_vector::{CircuitTestVector, load_mac, load_rfc},
    };
    use std::{collections::HashSet, io::Cursor};
    use wasm_bindgen_test::wasm_bindgen_test;

    #[wasm_bindgen_test(unsupported = test)]
    fn roundtrip_quad() {
        let quad = Quad {
            gate_index: 1,
            left_wire_index: 2,
            right_wire_index: 3,
            const_table_index: 4,
        };

        let next_quad = Quad {
            gate_index: 5,
            left_wire_index: 6,
            right_wire_index: 7,
            const_table_index: 8,
        };

        let mut encoded = Vec::new();
        quad.encode(None, &mut encoded).unwrap();
        let decoded = Quad::decode(None, &mut Cursor::new(&encoded)).unwrap();
        assert_eq!(quad, decoded);

        let mut next_encoded = Vec::new();
        next_quad.encode(Some(quad), &mut next_encoded).unwrap();
        let next_decoded = Quad::decode(Some(quad), &mut Cursor::new(&next_encoded)).unwrap();
        assert_eq!(next_quad, next_decoded);
    }

    fn roundtrip_circuit_test_vector<FE: CodecFieldElement>(
        (test_vector, circuit): (CircuitTestVector, Circuit<FE>),
    ) {
        // Verifies that circuits conform to a few invariants that we have interpreted from the
        // specification. Panics if any invariant does not hold for this circuit.
        //
        // It would be nice to do this in `Circuit::decode`, but we need to know which field
        // element is in use.
        assert_eq!(
            FieldId::try_from(test_vector.field).unwrap(),
            circuit.field_id()
        );
        assert_eq!(Size::from(test_vector.depth - 1), circuit.num_layers());
        assert_eq!(test_vector.depth as usize - 1, circuit.layers.len());

        let mut quads_count = 0;
        for (layer_index, layer) in circuit.layers.iter().enumerate() {
            let mut q_quad_gates = HashSet::new();
            let mut z_quad_gates = HashSet::new();

            for (quad_index, quad) in layer.quads.iter().enumerate() {
                assert!(quad.left_wire_index < layer.num_wires());
                assert!(quad.right_wire_index < layer.num_wires());
                assert!(quad.const_table_index < circuit.constant_table.len());

                let next_layer_num_wires = if layer_index == 0 {
                    circuit.num_outputs()
                } else {
                    // The Longfellow convention is that layer 0 is outputs and layer num_layers is
                    // inputs, so the next layer of the circuit is -1.
                    // https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-01#section-6.3.1
                    circuit.layers[layer_index - 1].num_wires()
                };
                if quad.gate_index() >= next_layer_num_wires {
                    panic!(
                        "quad {quad_index} on layer {layer_index} has gate number {} exceeding the \
                        number of input wires on the next layer",
                        quad.gate_index
                    );
                }

                // Force parsing of the constants
                let quad_value = circuit.constant(quad.const_table_index()).unwrap();
                if quad_value.is_zero().into() {
                    z_quad_gates.insert(quad.gate_index);
                } else {
                    q_quad_gates.insert(quad.gate_index);
                }
            }

            // Our interpretation of the specification is that gates should get contributions from
            // either Q or Z but never both.
            let intersection: Vec<_> = q_quad_gates.intersection(&z_quad_gates).collect();
            assert!(intersection.is_empty(), "Q and Z quads intersect");

            quads_count += layer.quads.len();
        }
        assert_eq!(test_vector.quads as usize, quads_count);
        assert_eq!(
            circuit.get_encoded().unwrap(),
            test_vector.serialized_circuit
        );
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn roundtrip_circuit_longfellow_rfc_1() {
        roundtrip_circuit_test_vector::<FieldP128>(load_rfc());
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn roundtrip_circuit_test_vector_mac() {
        roundtrip_circuit_test_vector::<Field2_128>(load_mac());
    }

    fn evaluate_circuit_true<FE: CodecFieldElement>(
        test_vector: CircuitTestVector,
        circuit: Circuit<FE>,
    ) {
        let evaluation: Evaluation<FE> = circuit.evaluate(&test_vector.valid_inputs()).unwrap();

        // Output size should match circuit serialization and values should all be zero
        assert_eq!(circuit.num_outputs(), evaluation.wires[0].len());
        for output in evaluation.outputs() {
            assert_eq!(*output, FE::ZERO);
        }

        // The remaining wire layers should match wire counts claimed by circuit serialization
        for (circuit_layer, evaluation_layer) in
            circuit.layers.iter().zip(evaluation.wires[1..].iter())
        {
            assert_eq!(circuit_layer.num_wires, evaluation_layer.len());
        }
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_circuit_longfellow_rfc_1_true() {
        let (test_vector, circuit) = load_rfc();
        evaluate_circuit_true::<FieldP128>(test_vector, circuit);
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_circuit_mac_true() {
        let (test_vector, circuit) = load_mac();
        evaluate_circuit_true::<Field2_128>(test_vector, circuit);
    }

    fn evaluate_circuit_false<FE: CodecFieldElement>(
        test_vector: CircuitTestVector,
        circuit: Circuit<FE>,
    ) {
        // Evaluate with other values. At least one output element should be nonzero.
        assert!(
            circuit
                .evaluate(&test_vector.invalid_inputs())
                .unwrap()
                .outputs()
                .iter()
                .any(|output: &FE| *output != FE::ZERO)
        );
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_circuit_longfellow_rfc_1_false() {
        let (test_vector, circuit) = load_rfc();
        evaluate_circuit_false::<FieldP128>(test_vector, circuit);
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_circuit_mac_false() {
        let (test_vector, circuit) = load_mac();
        evaluate_circuit_false::<Field2_128>(test_vector, circuit);
    }

    /// This test uses `include_bytes!()` instead of reading from files at runtime, so it can be run
    /// in a browser.
    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_circuit_longfellow_rfc_1_true_include_bytes() {
        let circuit_bytes = include_bytes!(
            "../test-vectors/one-circuit/longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b.circuit.zst"
        );
        let serialized_circuit = zstd::decode_all(Cursor::new(&circuit_bytes)).unwrap();
        let circuit = Circuit::decode(&mut Cursor::new(&serialized_circuit)).unwrap();

        let test_vector: CircuitTestVector = serde_json::from_slice(include_bytes!(
            "../test-vectors/one-circuit/longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b.json"
        ))
        .unwrap();

        assert_eq!(circuit.num_quads(), test_vector.quads as usize);

        let evaluation: Evaluation<FieldP128> =
            circuit.evaluate(&test_vector.valid_inputs()).unwrap();

        for output in evaluation.outputs() {
            assert_eq!(*output, FieldP128::ZERO);
        }
    }

    /// This creates a simple circuit that exercises in-circuit assertions.
    ///
    /// It takes one input, x, checks that x - 2 = 0 with an in-circuit assertion, and outputs
    /// (x - 1) * (x - 2). Following convention, the input wire V[3][0] is set to the constant value
    /// of 1, and V[3][1] is set to the input x. The circuit executes the following equations.
    ///
    /// ```text
    /// // Propagate 1 to next layer.
    /// V[2][0] = 1 * V[3][0] * V[3][0]
    /// // Calculate x^2 - 3x + 2.
    /// V[2][1] = 1 * V[3][1] * V[3][1] + -3 * V[3][1] * V[3][0] + 2 * V[3][0] * V[3][0]
    /// // Propagate x to next layer (for assertion).
    /// V[2][2] = 1 * V[3][1] * V[3][0]
    /// // Calculate -2 (for assertion).
    /// V[2][3] = -2 * V[3][0] * V[3][0]
    ///
    /// // Propagate 1 to next layer.
    /// V[1][0] = 1 * V[2][0] * V[2][0]
    /// // Propagate x^2 - 3x + 2 to next layer.
    /// V[1][1] = 1 * V[2][1] * V[2][0]
    /// // Assert x - 2 = 0. (occupying gate #2 on this layer)
    /// 0 = V[2][2] * V[2][0] + V[2][3] * V[2][0]
    ///
    /// // Propagate x^2 - 3x + 2 to output.
    /// V[0][0] = 1 * V[1][1] * V[1][0]
    /// ```
    fn make_assertion_test_circuit() -> Circuit<FieldP128> {
        let constant_table = vec![
            FieldP128::ZERO,
            FieldP128::ONE,
            FieldP128::from(2),
            -FieldP128::from(2), // constant table index 3
            -FieldP128::from(3), // constant table index 4
        ];
        let layers = vec![
            CircuitLayer {
                logw: Size(2),
                num_wires: Size(3),
                quads: vec![Quad {
                    // Propagate x^2 - 3x + 2 to output.
                    // V[0][0] = 1 * V[1][1] * V[1][0]
                    gate_index: 0,
                    left_wire_index: 1,
                    right_wire_index: 0,
                    const_table_index: 1,
                }],
            },
            CircuitLayer {
                logw: Size(2),
                num_wires: Size(4),
                quads: vec![
                    // Propagate 1 to next layer.
                    // V[1][0] = 1 * V[2][0] * V[2][0]
                    Quad {
                        gate_index: 0,
                        left_wire_index: 0,
                        right_wire_index: 0,
                        const_table_index: 1,
                    },
                    // Propagate x^2 - 3x + 2 to next layer.
                    // V[1][1] = 1 * V[2][1] * V[2][0]
                    Quad {
                        gate_index: 1,
                        left_wire_index: 1,
                        right_wire_index: 0,
                        const_table_index: 1,
                    },
                    // Assert x - 2 = 0. (occupying gate #2 on this layer)
                    // 0 = V[2][2] * V[2][0] + V[2][3] * V[2][0]
                    Quad {
                        gate_index: 2,
                        left_wire_index: 2,
                        right_wire_index: 0,
                        const_table_index: 0,
                    },
                    Quad {
                        gate_index: 2,
                        left_wire_index: 3,
                        right_wire_index: 0,
                        const_table_index: 0,
                    },
                ],
            },
            CircuitLayer {
                logw: Size(1),
                num_wires: Size(2),
                quads: vec![
                    // Propagate 1 to next layer.
                    // V[2][0] = 1 * V[3][0] * V[3][0]
                    Quad {
                        gate_index: 0,
                        left_wire_index: 0,
                        right_wire_index: 0,
                        const_table_index: 1,
                    },
                    // Calculate x^2 - 3x + 2.
                    // V[2][1] = 1 * V[3][1] * V[3][1] + -3 * V[3][1] * V[3][0] + 2 * V[3][0] * V[3][0]
                    Quad {
                        gate_index: 1,
                        left_wire_index: 1,
                        right_wire_index: 1,
                        const_table_index: 1,
                    },
                    Quad {
                        gate_index: 1,
                        left_wire_index: 1,
                        right_wire_index: 0,
                        const_table_index: 4,
                    },
                    Quad {
                        gate_index: 1,
                        left_wire_index: 0,
                        right_wire_index: 0,
                        const_table_index: 2,
                    },
                    // Propagate x to next layer (for assertion).
                    // V[2][2] = 1 * V[3][1] * V[3][0]
                    Quad {
                        gate_index: 2,
                        left_wire_index: 1,
                        right_wire_index: 0,
                        const_table_index: 1,
                    },
                    // Calculate -2 (for assertion).
                    // V[2][3] = -2 * V[3][0] * V[3][0]
                    Quad {
                        gate_index: 3,
                        left_wire_index: 0,
                        right_wire_index: 0,
                        const_table_index: 3,
                    },
                ],
            },
        ];
        Circuit {
            version: 1,
            field: FieldId::FP128,
            num_outputs: 1,
            num_copies: 0,
            num_public_inputs: 1,
            subfield_boundary: 1,
            num_inputs: 1,
            num_layers: layers.len(),
            constant_table,
            layers,
            id: [0; 32],
        }
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_assertion_pass_partial() {
        // The input value of 1 should cause the in-circuit assertion to fail. The circuit output is still zero.
        let circuit = make_assertion_test_circuit();
        let error = circuit.evaluate(&[FieldP128::ONE]).unwrap_err();
        assert!(error.to_string().contains("assertion failed"));
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_assertion_fail() {
        // This input should cause both the in-circuit assertion to fail and the circuit output be non-zero.
        let circuit = make_assertion_test_circuit();
        let error = circuit.evaluate(&[FieldP128::from_u128(5)]).unwrap_err();
        assert!(error.to_string().contains("assertion failed"));
    }

    #[wasm_bindgen_test(unsupported = test)]
    fn evaluate_assertion_pass_full() {
        // The input value of 2 satisfies both the in-circuit assertion and the circuit output condition.
        let circuit = make_assertion_test_circuit();
        let evaluation = circuit.evaluate(&[FieldP128::from_u128(2)]).unwrap();
        assert_eq!(evaluation.outputs()[0], FieldP128::ZERO);
    }
}
