use crate::{
    Codec, Size,
    fields::{FieldElement, FieldId, SerializedFieldElement},
};
use anyhow::{Context, anyhow};
use educe::Educe;
use std::{
    fmt::{self, Formatter},
    io::{Cursor, Read},
};

/// A circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, PartialEq, Eq, Educe)]
#[educe(Debug)]
pub struct Circuit {
    /// 1 byte version. Currently always 1.
    pub(crate) version: u8,
    /// The field this circuit uses. (not clear what subfield is used; hard coded to P256?)
    pub(crate) field: FieldId,
    /// Number of output wires (also `nv` in some places).
    pub(crate) num_outputs: Size,
    /// Number of copies (what's a copy? is this used?)
    pub(crate) num_copies: Size,
    /// Number of public inputs.
    pub(crate) num_public_inputs: Size,
    /// Least input wire not known to be in the subfield (what's the subfield though?)
    pub(crate) subfield_boundary: Size,
    /// Number of inputs, including witnesses. Always >= num_public_inputs, which is the index of
    /// of the first private input.
    pub(crate) num_inputs: Size,
    /// Number of layers in the circuit.
    pub(crate) num_layers: Size,
    /// Array of constants pointed to by the circuit's quads. Encoded as a variable length array of
    /// [`SerializedFieldElement`], which can then be decoded into a particular [`FieldElement`]
    /// implementation based on the value of `field`.
    pub(crate) constant_table: Vec<SerializedFieldElement>,
    /// The layers of the circuit. There are num_layers of these, so this gets serialized as a fixed
    /// length array.
    pub(crate) layers: Vec<CircuitLayer>,
    /// 32 byte identifier for the circuit. Generated by the circuit compiler.
    #[educe(Debug(method(fmt_id)))]
    pub(crate) id: [u8; 32],
}

fn fmt_id(s: &[u8; 32], f: &mut Formatter<'_>) -> fmt::Result {
    f.write_str(hex::encode(s).as_str())
}

impl Codec for Circuit {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let version = u8::decode(bytes)?;
        let field = FieldId::decode(bytes)?;
        let num_outputs = Size::decode(bytes)?;
        let num_copies = Size::decode(bytes)?;
        let num_public_inputs = Size::decode(bytes)?;
        let subfield_boundary = Size::decode(bytes)?;
        let num_inputs = Size::decode(bytes)?;
        let num_layers = Size::decode(bytes)?;
        let num_constants = Size::decode(bytes)?;

        // Decode constant table: first a count of elements, then each element's length is obtained
        // from the field ID.
        let mut constant_table = Vec::with_capacity(usize::from(num_constants));
        for _ in 0..num_constants.into() {
            constant_table.push(SerializedFieldElement::decode(field, bytes)?);
        }

        let layers = CircuitLayer::decode_fixed_array(bytes, num_layers.into())
            .context("failed to decode layers")?;
        let mut id = [0u8; 32];
        bytes
            .read_exact(&mut id)
            .context("failed to read 32 bytes of circuit ID")?;

        Ok(Self {
            version,
            field,
            num_outputs,
            num_copies,
            num_public_inputs,
            subfield_boundary,
            num_inputs,
            num_layers,
            constant_table,
            layers,
            id,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.version.encode(bytes)?;
        self.field.encode(bytes)?;
        self.num_outputs.encode(bytes)?;
        self.num_copies.encode(bytes)?;
        self.num_public_inputs.encode(bytes)?;
        self.subfield_boundary.encode(bytes)?;
        self.num_inputs.encode(bytes)?;
        self.num_layers.encode(bytes)?;

        // Encode constant table: first a count of elements, then each element's length is obtained
        // from the field ID.
        Size::from(self.constant_table.len() as u32).encode(bytes)?;
        for constant in &self.constant_table {
            constant.encode(bytes)?;
        }

        if usize::from(self.num_layers) != self.layers.len() {
            return Err(anyhow!("num_layers does not match length of layers array"));
        }
        CircuitLayer::encode_fixed_array(&self.layers, bytes)?;
        bytes.extend_from_slice(&self.id);

        Ok(())
    }
}

impl Circuit {
    /// Retrieve the requested constant from the circuit's constant table, if it exists.
    pub fn constant<F: FieldElement>(&self, index: Size) -> Result<F, anyhow::Error> {
        F::try_from(
            &self
                .constant_table
                .get(usize::from(index))
                .ok_or_else(|| anyhow!("index {} not present in constant table", index))?
                .clone()
                .0,
        )
    }
}

/// A layer of a circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, Educe, PartialEq, Eq)]
#[educe(Debug)]
pub struct CircuitLayer {
    /// This is the number of bits needed to name a wire on this layer ([1]). Thus, it's usually
    /// `ceil(log_2(num_wires))`, but apparently not always. The value of output wire i is 0 for
    /// `i >= 2^logw`, because there are no such wires at this layer.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.2
    ///
    /// Longfellow calls this "number of binding rounds for the hand variables".
    pub(crate) logw: Size,
    /// Number of wires/inputs to the layer.
    pub(crate) num_wires: Size,
    /// Quads describing this layer of the circuit. A variable length array.
    ///
    /// [5.3.3.][1] discusses the combined circuit QZ = Q + beta * Z for some random beta. beta is
    /// chosen during proof generation, and so is not serialized. However the combined quad does
    /// impact the serialization format: because Q and Z are disjoint matrices, then any quad whose
    /// value is nonzero is understood to be part of Q, and any quad whose value is zero is
    /// understood to be part of Z.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    pub(crate) quads: Vec<Quad>,
}

impl Codec for CircuitLayer {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let logw = Size::decode(bytes)?;
        let num_wires = Size::decode(bytes)?;
        let num_quads = Size::decode(bytes)?;

        let mut prev_quad = None;
        let mut quads = Vec::with_capacity(num_quads.into());
        for _ in 0..num_quads.0 {
            let quad = Quad::decode(prev_quad, bytes)?;
            prev_quad = Some(quad);
            quads.push(quad);
        }

        Ok(Self {
            logw,
            num_wires,
            quads,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.logw.encode(bytes)?;
        self.num_wires.encode(bytes)?;
        Size::from(self.quads.len() as u32).encode(bytes)?;

        let mut prev_quad = None;
        for quad in &self.quads {
            quad.encode(prev_quad, bytes)?;
            prev_quad = Some(*quad);
        }

        Ok(())
    }
}

/// A quad describes an individual gate in the circuit, serialized according to struct Quad in [1]
/// and the ad-hoc definition in [2] and [3].
///
/// [2] and [3] implement a `struct Quad` which in turn contains a vector of `Quad::corner`. Each
/// `corner` value corresponds to the draft's `struct Quad`.
///
/// [1]: https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-00#section-7.6
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [3]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/quad.h
#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]
pub struct Quad {
    /// The position of ths gate in its layer.
    pub(crate) gate_number: Size,
    /// Index of the left-hand wire feeding into this gate.
    pub(crate) left_wire: Size,
    /// Index of the right-hand wire feeding into this gate.
    pub(crate) right_wire: Size,
    /// Index into the circuit's constant table. The value at that index is the quad's value. If the
    /// value is 0, the quad is part of Z. If the value is nonzero, the quad is part of Q. See [1]
    /// for discussion of the combined quad.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    pub(crate) const_table_index: Size,
}

impl Quad {
    /// Encode this quad as deltas relative to the previous quad in the circuit.
    // XXX extend [`crate::Codec`] to take an encoding parameter like prio::codec does so we can
    // pass in prev_quad
    fn encode(&self, prev_quad: Option<Quad>, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        self.gate_number
            .encode_delta(prev_quad.gate_number, bytes)?;
        self.left_wire.encode_delta(prev_quad.left_wire, bytes)?;
        self.right_wire.encode_delta(prev_quad.right_wire, bytes)?;
        self.const_table_index.encode(bytes)?;

        Ok(())
    }

    /// Encode this quad as deltas relative to the previous quad in the circuit.
    fn decode(prev_quad: Option<Quad>, bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        let gate_number = Size::decode_delta(prev_quad.gate_number, bytes)?;
        let left_wire = Size::decode_delta(prev_quad.left_wire, bytes)?;
        let right_wire = Size::decode_delta(prev_quad.right_wire, bytes)?;
        let const_table_index = Size::decode(bytes)?;

        Ok(Self {
            gate_number,
            left_wire,
            right_wire,
            const_table_index,
        })
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use crate::{
        Codec, Size,
        circuit::{Circuit, Quad},
        fields::{FieldId, fieldp128::FieldP128, fieldp256::FieldP256},
    };
    use serde::Deserialize;
    use std::{
        fs::File,
        io::{BufReader, Cursor, Read},
    };

    #[test]
    fn roundtrip_quad() {
        let quad = Quad {
            gate_number: Size(1),
            left_wire: Size(2),
            right_wire: Size(3),
            const_table_index: Size(4),
        };

        let next_quad = Quad {
            gate_number: Size(5),
            left_wire: Size(6),
            right_wire: Size(7),
            const_table_index: Size(8),
        };

        let mut encoded = Vec::new();
        quad.encode(None, &mut encoded).unwrap();
        let decoded = Quad::decode(None, &mut Cursor::new(&encoded)).unwrap();
        assert_eq!(quad, decoded);

        let mut next_encoded = Vec::new();
        next_quad.encode(Some(quad), &mut next_encoded).unwrap();
        let next_decoded = Quad::decode(Some(quad), &mut Cursor::new(&next_encoded)).unwrap();
        assert_eq!(next_quad, next_decoded);
    }

    /// JSON descriptor of a circuit test vector.
    #[derive(Debug, Clone, Deserialize)]
    pub(crate) struct CircuitTestVector {
        #[allow(dead_code)]
        pub(crate) description: String,
        /// Field used by the circuit.
        pub(crate) field: u8,
        /// Depth of the circuit. This is wire layers, not gate layers.
        pub(crate) depth: u32,
        /// Total quads in the circuit.
        pub(crate) quads: u32,
        /// Not yet clear what this is.
        pub(crate) _terms: u32,
        /// The serialized circuit, stored in a file alongside the JSON descriptor.
        #[serde(default)]
        pub(crate) serialized_circuit: Vec<u8>,
    }

    impl CircuitTestVector {
        pub(crate) fn decode(test_vector_name: &'static str) -> (Self, Circuit) {
            let test_vector_path = format!("test-vectors/circuit/{test_vector_name}");

            let mut test_vector: Self = serde_json::from_reader(BufReader::new(
                File::open(format!("{test_vector_path}.json")).unwrap(),
            ))
            .unwrap();

            File::open(format!("{test_vector_path}.circuit"))
                .unwrap()
                .read_to_end(&mut test_vector.serialized_circuit)
                .unwrap();

            let mut cursor = Cursor::new(test_vector.serialized_circuit.as_slice());
            let circuit = Circuit::decode(&mut cursor).unwrap();

            assert_eq!(
                cursor.position() as usize,
                test_vector.serialized_circuit.len(),
                "bytes left over after parsing circuit"
            );

            (test_vector, circuit)
        }
    }

    fn roundtrip_circuit_test_vector(name: &'static str) {
        let (test_vector, circuit) = CircuitTestVector::decode(name);

        assert_eq!(FieldId::try_from(test_vector.field).unwrap(), circuit.field);
        assert_eq!(Size::from(test_vector.depth - 1), circuit.num_layers);
        assert_eq!(test_vector.depth as usize - 1, circuit.layers.len());

        let mut quads_count = 0;
        for layer in &circuit.layers {
            for quad in &layer.quads {
                assert!(quad.left_wire < layer.num_wires);
                assert!(quad.right_wire < layer.num_wires);
                assert!(quad.const_table_index < circuit.constant_table.len());

                // Force parsing of the constants
                match circuit.field {
                    FieldId::None => panic!("circuit can't have Field::None"),
                    FieldId::P256 => {
                        circuit
                            .constant::<FieldP256>(quad.const_table_index)
                            .unwrap();
                    }
                    FieldId::FP128 => {
                        circuit
                            .constant::<FieldP128>(quad.const_table_index)
                            .unwrap();
                    }
                }

                assert!(quad.gate_number < layer.quads.len());
            }

            quads_count += layer.quads.len();
        }
        assert_eq!(test_vector.quads as usize, quads_count);
        let mut encoded_again = Vec::new();
        circuit.encode(&mut encoded_again).unwrap();
        assert_eq!(encoded_again, test_vector.serialized_circuit);
    }

    #[test]
    fn roundtrip_circuit_longfellow_rfc_1() {
        roundtrip_circuit_test_vector("longfellow-rfc-1-87474f308020535e57a778a82394a14106f8be5b");
    }

    #[test]
    fn roundtrip_circuit_test_vector_mac() {
        roundtrip_circuit_test_vector(
            "longfellow-mac-circuit-902a955fbb22323123aac5b69bdf3442e6ea6f80-1",
        );
    }
}
