//! Various prime order fields. Each is defined in its own submodule because otherwise the names of
//! items generated by the [`ff::PrimeField`] macro collide.
use anyhow::anyhow;
use ff::PrimeField;

pub trait FieldElement: PrimeField + for<'a> TryFrom<&'a [u8], Error = anyhow::Error> {
    /// Number of bytes needed to represent a field element.
    fn num_bytes() -> usize {
        (Self::NUM_BITS as usize).div_ceil(8)
    }
}

pub mod fieldp256 {
    use super::*;

    /// FieldP256 is the field for the NIST P256 elliptic curve.
    ///
    /// The generator is computed in [SageMath][1].
    ///
    /// [1]: https://sagecell.sagemath.org/?z=eJwFwckNg0AQBMB04IOmp-dMwITh1z5WMgghRPyu2j8L4Nkq1Qqhh1plaHSaRVubpCedIhUwGlxbCEO7k0FQqiKls5ztWLfrnsd85ju-4zeOcT7L-gdkdBh6&lang=sage&interacts=eJyLjgUAARUAuQ==
    #[derive(ff::PrimeField)]
    #[PrimeFieldModulus = "115792089210356248762697446949407573530086143415290314195533631308867097853951"]
    #[PrimeFieldGenerator = "6"]
    #[PrimeFieldReprEndianness = "little"]
    pub struct FieldP256([u64; 5]);

    impl FieldElement for FieldP256 {}

    impl TryFrom<&[u8]> for FieldP256 {
        type Error = anyhow::Error;

        fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
            // Empirically, FieldP256Repr is 40 bytes
            const REPR_LEN: usize = 40;

            if value.len() > REPR_LEN {
                return Err(anyhow!("slice is too long for field representation"));
            }

            let mut padded = [0u8; REPR_LEN];
            padded[..value.len()].copy_from_slice(value);

            Self::from_repr(FieldP256Repr(padded))
                // TODO: this is not constant time.
                .into_option()
                .ok_or_else(|| anyhow!("cannot construct field element from value"))
        }
    }
}

pub mod fieldp128 {
    use super::*;

    /// FieldP128 is the field with modulus 2^128 - 2^108 + 1, described in [Section 7.2 of
    /// draft-google-cfrg-libzk-00][1]. The field does not get a name in the draft, but P128 comes from
    /// the longfellow implementation ([3]).
    ///
    /// The generator was computed in [SageMath][4] (thanks to the hint in
    /// [`PrimeField::MULTIPLICATIVE_GENERATOR`]).
    ///
    /// The endianness is per [Section 7.2.1 of draft-google-cfrg-libzk-00][2].
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-7.2
    /// [2]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-7.2.1
    /// [3]: https://github.com/google/longfellow-zk/blob/main/lib/algebra/fp_p128.h
    /// [4]: https://sagecell.sagemath.org/?z=eJxzd9MwijM0stAFkgYW2oaaegVFmbmZJZllqfGpOam5qXklGpoAwO8LXQ==&lang=sage&interacts=eJyLjgUAARUAuQ==
    #[derive(ff::PrimeField)]
    #[PrimeFieldModulus = "340282042402384805036647824275747635201"]
    #[PrimeFieldGenerator = "59"]
    #[PrimeFieldReprEndianness = "little"]
    // ff requires that the repr be an array of u64 and despite the fact that 128 bits should be big
    // enough, also requires 3 u64s.
    pub struct FieldP128([u64; 3]);

    impl FieldElement for FieldP128 {}

    impl TryFrom<&[u8]> for FieldP128 {
        type Error = anyhow::Error;

        fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
            // Empirically, FieldP128Repr is 24 bytes
            const REPR_LEN: usize = 24;

            if value.len() > REPR_LEN {
                return Err(anyhow!("slice is too long for field representation"));
            }

            let mut padded = [0u8; REPR_LEN];
            padded[..value.len()].copy_from_slice(value);

            Self::from_repr(FieldP128Repr(padded))
                // TODO: this is not constant time.
                .into_option()
                .ok_or_else(|| anyhow!("cannot construct field element from value"))
        }
    }
}

pub mod fieldp521 {
    use super::*;

    /// FieldP521 is the field with modulus 2^521 - 1, described in [Section 7.2 of
    /// draft-google-cfrg-libzk-00][1].
    /// The generator was computed in [SageMath][4] (thanks to the hint in
    /// [`PrimeField::MULTIPLICATIVE_GENERATOR`]).
    ///
    /// The endianness is per [Section 7.2.1 of draft-google-cfrg-libzk-00][2].
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-7.2
    /// [2]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-7.2.1
    /// [4]: https://sagecell.sagemath.org/?z=eJxzd9MwijM1MtQ11NQrKMrMzSzJLEuNT81JzU3NK9HQBACSMgoG&lang=sage&interacts=eJyLjgUAARUAuQ==
    #[derive(ff::PrimeField)]
    #[PrimeFieldModulus = "6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151"]
    #[PrimeFieldGenerator = "3"]
    #[PrimeFieldReprEndianness = "little"]
    pub struct FieldP521([u64; 9]);

    impl FieldElement for FieldP521 {}

    impl TryFrom<&[u8]> for FieldP521 {
        type Error = anyhow::Error;

        fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
            // Empirically, FieldP521Repr is 72 bytes
            const REPR_LEN: usize = 72;

            if value.len() > REPR_LEN {
                return Err(anyhow!("slice is too long for field representation"));
            }

            let mut padded = [0u8; REPR_LEN];
            padded[..value.len()].copy_from_slice(value);

            Self::from_repr(FieldP521Repr(padded))
                // TODO: this is not constant time
                .into_option()
                .ok_or_else(|| anyhow!("cannot construct field element from value"))
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{fieldp128::FieldP128, fieldp256::FieldP256};

    #[test]
    fn field_p128_from_bytes_accept() {
        for (label, valid_element) in [
            (
                "Fewer bytes than the repr. We should pad with zeroes.",
                &[0xff][..],
            ),
            (
                "Exactly the length of the repr (24 bytes), but a legal field value.",
                &[
                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ][..],
            ),
            (
                "Empty slice should be padded and evaluate to zero.",
                &[][..],
            ),
        ] {
            FieldP128::try_from(valid_element).expect(label);
        }
    }

    #[test]
    fn field_p128_from_bytes_reject() {
        for (label, invalid_element) in [
            (
                "Value is too big for the field",
                &[
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                ][..],
            ),
            (
                "Slice is too long for the field repr",
                &[
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ][..],
            ),
        ] {
            FieldP128::try_from(invalid_element).expect_err(label);
        }
    }

    #[test]
    fn field_p256_from_bytes_accept() {
        for (label, valid_element) in [
            (
                "Fewer bytes than the repr. We should pad with zeroes.",
                &[0xff][..],
            ),
            (
                "Exactly the length of the repr (40 bytes), but a legal field value.",
                &[
                    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00,
                ][..],
            ),
            (
                "Empty slice should be padded and evaluate to zero.",
                &[][..],
            ),
        ] {
            FieldP256::try_from(valid_element).expect(label);
        }
    }

    #[test]
    fn field_p256_from_bytes_reject() {
        for (label, invalid_element) in [
            (
                "Value is too big for the field",
                &[
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                    0xff,
                ][..],
            ),
            (
                "Slice is too long for the field repr",
                &[
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00,
                ][..],
            ),
        ] {
            FieldP256::try_from(invalid_element).expect_err(label);
        }
    }
}
