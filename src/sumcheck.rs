//! Implements sumcheck, which is a system that for some circuit `C`, an input `x` and a witness
//! `w`, `C(x, w) = 0`.

use crate::{Codec, FieldId, Size};
use anyhow::{Context, anyhow};
use educe::Educe;
use std::{
    fmt::{self, Formatter},
    io::{Cursor, Read},
};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

/// A circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, PartialEq, Eq, Educe)]
#[educe(Debug)]
pub struct SerializedCircuit {
    /// 1 byte version. Currently always 1.
    version: u8,
    /// The field this circuit uses. (not clear what subfield is used; hard coded to P256?)
    field: FieldId,
    /// Number of output wires (also `nv` in some places).
    num_outputs: Size,
    /// Number of copies (what's a copy? is this used?)
    num_copies: Size,
    /// Number of public inputs.
    num_public_inputs: Size,
    /// Lease input wire not known to be in the subfield (what's the subfield though?)
    subfield_boundary: Size,
    /// Number of inputs, including witnesses. Always >= num_public_inputs, which is the index of
    /// of the first private input.
    num_inputs: Size,
    /// Number of layers in the circuit.
    num_layers: Size,
    /// Array of constants pointed to by the circuit's quads. For now, we cheat and always use
    /// `FieldP128`. Encoded as a variable length array.
    constant_table: Vec<SerializedFieldP128>,
    /// The layers of the circuit. There are num_layers of these, so this gets serialized as a fixed
    /// length array.
    layers: Vec<SerializedCircuitLayer>,
    /// 32 byte identifier for the circuit. Generated by the circuit compiler.
    #[educe(Debug(method(fmt_id)))]
    id: [u8; 32],
}

fn fmt_id(s: &[u8; 32], f: &mut Formatter<'_>) -> fmt::Result {
    f.write_str(hex::encode(s).as_str())
}

impl Codec for SerializedCircuit {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let version = u8::decode(bytes)?;
        let field = FieldId::decode(bytes)?;
        let num_outputs = Size::decode(bytes)?;
        let num_copies = Size::decode(bytes)?;
        let num_public_inputs = Size::decode(bytes)?;
        let subfield_boundary = Size::decode(bytes)?;
        let num_inputs = Size::decode(bytes)?;
        let num_layers = Size::decode(bytes)?;
        let constant_table =
            SerializedFieldP128::decode_array(bytes).context("failed to decode constant table")?;
        let layers = SerializedCircuitLayer::decode_fixed_array(bytes, num_layers.into())
            .context("failed to decode layers")?;
        let mut id = [0u8; 32];
        bytes
            .read_exact(&mut id)
            .context("failed to read 32 bytes of circuit ID")?;

        Ok(Self {
            version,
            field,
            num_outputs,
            num_copies,
            num_public_inputs,
            subfield_boundary,
            num_inputs,
            num_layers,
            constant_table,
            layers,
            id,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.version.encode(bytes)?;
        self.field.encode(bytes)?;
        self.num_outputs.encode(bytes)?;
        self.num_copies.encode(bytes)?;
        self.num_public_inputs.encode(bytes)?;
        self.subfield_boundary.encode(bytes)?;
        self.num_inputs.encode(bytes)?;
        self.num_layers.encode(bytes)?;
        SerializedFieldP128::encode_array(&self.constant_table, bytes)?;
        if usize::from(self.num_layers) != self.layers.len() {
            return Err(anyhow!("num_layers does not match length of layers array"));
        }
        SerializedCircuitLayer::encode_fixed_array(&self.layers, bytes)?;
        bytes.extend_from_slice(&self.id);

        Ok(())
    }
}

/// A layer of a circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, Educe, PartialEq, Eq)]
#[educe(Debug)]
pub struct SerializedCircuitLayer {
    /// "number of binding rounds for the hand variables". It's unclear what this means. Also
    /// unclear why it is called logw. Is it a logarithm?
    // XXX find better variable name once we know what this is
    logw: Size,
    /// Number of wires/inputs to the layer.
    num_wires: Size,
    /// Quads describing this layer of the circuit. A variable length array.
    /// XXX: 5.3.3. discusses a circuit defined by Q and Z, but effectvely collapsing them into a
    /// single quad because they are disjoint. Is that how the serialization works?
    quads: Vec<Quad>,
}

impl Codec for SerializedCircuitLayer {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let logw = Size::decode(bytes)?;
        let num_wires = Size::decode(bytes)?;
        let num_quads = Size::decode(bytes)?;

        let mut prev_quad = None;
        let mut quads = Vec::with_capacity(num_quads.into());
        for _ in 0..num_quads.0 {
            let quad = Quad::decode(prev_quad, bytes)?;
            prev_quad = Some(quad);
            quads.push(quad);
        }

        Ok(Self {
            logw,
            num_wires,
            quads,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.logw.encode(bytes)?;
        self.num_wires.encode(bytes)?;
        Size::from(self.quads.len() as u32).encode(bytes)?;

        let mut prev_quad = None;
        for quad in &self.quads {
            quad.encode(prev_quad, bytes)?;
            prev_quad = Some(*quad);
        }

        Ok(())
    }
}

/// A quad describes an individual gate in the circuit, serialized according to struct Quad in [1]
/// and the ad-hoc definition in [2] and [3].
///
/// [2] and [3] implement a `struct Quad` which in turn contains a vector of `Quad::corner`. Each
/// `corner` value corresponds to the draft's `struct Quad`.
///
/// [1]: https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-00#section-7.6
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/quad.h
#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]
pub struct Quad {
    /// The position of ths gate in its layer.
    gate_number: Size,
    /// Index of the left-hand wire feeding into this gate.
    left_wire: Size,
    /// Index of the right-hand wire feeding into this gate.
    right_wire: Size,
    /// Index into the circuit's constant table.
    const_table_index: Size,
}

impl Quad {
    /// Encode this quad as deltas relative to the previous quad in the circuit.
    // XXX extend [`crate::Codec`] to take an encoding parameter like prio::codec does so we can
    // pass in prev_quad
    fn encode(&self, prev_quad: Option<Quad>, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        self.gate_number
            .encode_delta(prev_quad.gate_number, bytes)?;
        self.left_wire.encode_delta(prev_quad.left_wire, bytes)?;
        self.right_wire.encode_delta(prev_quad.right_wire, bytes)?;
        self.const_table_index.encode(bytes)?;

        Ok(())
    }

    /// Encode this quad as deltas relative to the previous quad in the circuit.
    fn decode(prev_quad: Option<Quad>, bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        let gate_number = Size::decode_delta(prev_quad.gate_number, bytes)?;
        let left_wire = Size::decode_delta(prev_quad.left_wire, bytes)?;
        let right_wire = Size::decode_delta(prev_quad.right_wire, bytes)?;
        let const_table_index = Size::decode(bytes)?;

        Ok(Self {
            gate_number,
            left_wire,
            right_wire,
            const_table_index,
        })
    }
}

/// A serialized element of FieldP128.
#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Default)]
pub struct SerializedFieldP128(u128);

impl Codec for SerializedFieldP128 {
    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        bytes.write_u128::<LittleEndian>(self.0).context("failed to write u128")
    }

    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        Ok(Self(
            bytes
                .read_u128::<LittleEndian>()
                .context("failed to read u128")?,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde::Deserialize;
    use std::{fs::File, io::BufReader};

    #[derive(Debug, Clone, Deserialize)]
    struct CircuitTestVector {
        field: u32,
        serialized: String,
        depth: u32,
        quads: u32,
        _terms: u32,
    }

    #[test]
    fn codec_roundtrip_p128() {
        SerializedFieldP128(0xffffefffffffffffffffffffffffffff).roundtrip();
    }

    #[test]
    fn roundtrip_quad() {
        let quad = Quad {
            gate_number: Size(1),
            left_wire: Size(2),
            right_wire: Size(3),
            const_table_index: Size(4),
        };

        let next_quad = Quad {
            gate_number: Size(5),
            left_wire: Size(6),
            right_wire: Size(7),
            const_table_index: Size(8),
        };

        let mut encoded = Vec::new();
        quad.encode(None, &mut encoded).unwrap();
        let decoded = Quad::decode(None, &mut Cursor::new(&encoded)).unwrap();
        assert_eq!(quad, decoded);

        let mut next_encoded = Vec::new();
        next_quad.encode(Some(quad), &mut next_encoded).unwrap();
        let next_decoded = Quad::decode(Some(quad), &mut Cursor::new(&next_encoded)).unwrap();
        assert_eq!(next_quad, next_decoded);
    }

    #[test]
    fn roundtrip_circuit_test_vector() {
        let test_vector: CircuitTestVector = serde_json::from_reader(BufReader::new(
            File::open(
                "test-vectors/circuit/longfellow-87474f308020535e57a778a82394a14106f8be5b-1.json",
            )
            .unwrap(),
        ))
        .unwrap();

        // We only support FieldId 6 right now
        assert_eq!(test_vector.field, 6);

        let circuit_bytes = hex::decode(test_vector.serialized).unwrap();

        let mut cursor = Cursor::new(circuit_bytes.as_slice());
        let circuit = SerializedCircuit::decode(&mut cursor).unwrap();

        assert_eq!(cursor.position() as usize, circuit_bytes.len(), "bytes left over after parsing circuit");

        // The test vector says "depth: 3" but the serialized struct indicates 2 layers. It's not
        // clear what exactly is meant by "depth" or num_layers.
        assert_eq!(Size::from(test_vector.depth - 1), circuit.num_layers);
        assert_eq!(test_vector.depth as usize - 1, circuit.layers.len());

        let mut quads_count = 0;
        for layer in &circuit.layers {
            quads_count += layer.quads.len();
        }
        assert_eq!(test_vector.quads as usize, quads_count);

        let mut encoded_again = Vec::new();
        circuit.encode(&mut encoded_again).unwrap();
        assert_eq!(circuit_bytes, encoded_again);
    }
}
