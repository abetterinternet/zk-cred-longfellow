//! Implements sumcheck, which is a system that for some circuit `C`, an input `x` and a witness
//! `w`, `C(x, w) = 0`.

use crate::{Codec, FieldId, FieldP128, Size};
use anyhow::{Context, anyhow};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use educe::Educe;
use ff::{Field, PrimeField};
use std::{
    collections::BTreeMap,
    fmt::{self, Formatter},
    io::{Cursor, Read},
};

/// A circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, PartialEq, Eq, Educe)]
#[educe(Debug)]
pub struct Circuit {
    /// 1 byte version. Currently always 1.
    version: u8,
    /// The field this circuit uses. (not clear what subfield is used; hard coded to P256?)
    field: FieldId,
    /// Number of output wires (also `nv` in some places).
    num_outputs: Size,
    /// Number of copies (what's a copy? is this used?)
    num_copies: Size,
    /// Number of public inputs.
    num_public_inputs: Size,
    /// Lease input wire not known to be in the subfield (what's the subfield though?)
    subfield_boundary: Size,
    /// Number of inputs, including witnesses. Always >= num_public_inputs, which is the index of
    /// of the first private input.
    num_inputs: Size,
    /// Number of layers in the circuit.
    num_layers: Size,
    /// Array of constants pointed to by the circuit's quads. For now, we cheat and always use
    /// `FieldP128`. Encoded as a variable length array.
    constant_table: Vec<SerializedFieldP128>,
    /// The layers of the circuit. There are num_layers of these, so this gets serialized as a fixed
    /// length array.
    layers: Vec<CircuitLayer>,
    /// 32 byte identifier for the circuit. Generated by the circuit compiler.
    #[educe(Debug(method(fmt_id)))]
    id: [u8; 32],
}

fn fmt_id(s: &[u8; 32], f: &mut Formatter<'_>) -> fmt::Result {
    f.write_str(hex::encode(s).as_str())
}

impl Codec for Circuit {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let version = u8::decode(bytes)?;
        let field = FieldId::decode(bytes)?;
        let num_outputs = Size::decode(bytes)?;
        let num_copies = Size::decode(bytes)?;
        let num_public_inputs = Size::decode(bytes)?;
        let subfield_boundary = Size::decode(bytes)?;
        let num_inputs = Size::decode(bytes)?;
        let num_layers = Size::decode(bytes)?;
        let constant_table =
            SerializedFieldP128::decode_array(bytes).context("failed to decode constant table")?;
        let layers = CircuitLayer::decode_fixed_array(bytes, num_layers.into())
            .context("failed to decode layers")?;
        let mut id = [0u8; 32];
        bytes
            .read_exact(&mut id)
            .context("failed to read 32 bytes of circuit ID")?;

        Ok(Self {
            version,
            field,
            num_outputs,
            num_copies,
            num_public_inputs,
            subfield_boundary,
            num_inputs,
            num_layers,
            constant_table,
            layers,
            id,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.version.encode(bytes)?;
        self.field.encode(bytes)?;
        self.num_outputs.encode(bytes)?;
        self.num_copies.encode(bytes)?;
        self.num_public_inputs.encode(bytes)?;
        self.subfield_boundary.encode(bytes)?;
        self.num_inputs.encode(bytes)?;
        self.num_layers.encode(bytes)?;
        SerializedFieldP128::encode_array(&self.constant_table, bytes)?;
        if usize::from(self.num_layers) != self.layers.len() {
            return Err(anyhow!("num_layers does not match length of layers array"));
        }
        CircuitLayer::encode_fixed_array(&self.layers, bytes)?;
        bytes.extend_from_slice(&self.id);

        Ok(())
    }
}

impl Circuit {
    /// Evaluate the circuit with the provided inputs.
    pub fn evaluate(&self, inputs: &[u128]) -> Result<Evaluation, anyhow::Error> {
        let inputs: Vec<_> = inputs
            .iter()
            .map(|input| FieldP128::from_u128(*input))
            .collect();
        // There are n layers of gates, but with the inputs, we have n + 1 layers of wires.
        let mut wires = Vec::with_capacity(self.layers.len() + 1);

        // "By convention, the input wire Vj[0] = 1 for all layers, and thus the quad representation
        // handles the classic add and multiplication gates in a uniform manner."
        // This is because we represent constants in the circuit by multiplying the input 1 by
        // whatever the value we need. We apply this fixup only for the first layer, as subsequent
        // layers are constructed to propagate the constant 1.
        //
        // https://eprint.iacr.org/2024/2010.pdf, section 2.1
        wires.push([&[FieldP128::ONE], inputs.as_slice()].concat());

        for (layer_index, layer) in self
            .layers
            .iter()
            // In the serialized format, the input layer comes last, so reverse the layers iterator.
            .rev()
            .enumerate()
        {
            // A single gate may receive contributions from multiple quads, so accumulate gate
            // evaluations into a BTreeMap keyed by gate number, which can then be efficiently
            // converted to a vector of gate output values.
            let mut gate_outputs = BTreeMap::new();
            for (quad_index, quad) in layer.quads.iter().enumerate() {
                // Evaluate this quad: look up its value in the constants table, then multiply that
                // by the value of the input wires.
                let quad_value = FieldP128::from(
                    *self
                        .constant_table
                        .get(usize::from(quad.const_table_index))
                        .ok_or_else(|| {
                            anyhow!(
                                "quad {quad_index} on layer {layer_index} contains constant table \
                                index {:?} not present in constant table",
                                quad.const_table_index
                            )
                        })?,
                );
                let left_wire = wires[layer_index].get(usize::from(quad.left_wire)).ok_or_else(|| {
                    anyhow!(
                        "quad {quad_index} on layer {layer_index} contains left wire index {:?} \
                        not present in previous layer of circuit {:?}",
                        quad.left_wire, wires[layer_index],
                    )
                })?;
                let right_wire = wires[layer_index]
                    .get(usize::from(quad.right_wire))
                    .ok_or_else(|| {
                        anyhow!(
                            "quad {quad_index} on layer {layer_index} contains right wire index \
                            {:?} not present in previous layer of circuit {:?}",
                            quad.right_wire,
                            wires[layer_index],
                        )
                    })?;

                let quad_output = quad_value * left_wire * right_wire;

                gate_outputs
                    .entry(quad.gate_number)
                    .and_modify(|v| *v += quad_output)
                    .or_insert(quad_output);
            }

            wires.push(gate_outputs.into_values().collect());
        }

        // Reverse wires so that the inputs come last and the outputs come first.
        wires.reverse();
        Ok(Evaluation { wires })
    }
}

/// The evaluation of a circuit.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Evaluation {
    /// The value of each of the wires of the circuit after evaluation. An n-layer circuit has n+1
    /// layers of wire values. Layer index 0 is the outputs and layer index n is the inputs. The
    /// length of each layer depends on the number of gates on each later.
    wires: Vec<Vec<FieldP128>>,
}

impl Evaluation {
    pub fn outputs(&self) -> &[FieldP128] {
        self.wires[0].as_slice()
    }
}

/// A layer of a circuit, serialized according to the ad-hoc definition in [1] and [2].
///
/// [1]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/circuit.h
#[derive(Clone, Educe, PartialEq, Eq)]
#[educe(Debug)]
pub struct CircuitLayer {
    /// This is the number of bits needed to name a wire on this layer ([1]). Thus, it's usually
    /// `ceil(log_2(num_wires))`, but apparently not always. The value of output wire i is 0 for
    /// `i >= 2^logw`, because there are no such wires at this layer.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.2
    ///
    /// Longfellow calls this "number of binding rounds for the hand variables".
    logw: Size,
    /// Number of wires/inputs to the layer.
    num_wires: Size,
    /// Quads describing this layer of the circuit. A variable length array.
    ///
    /// [5.3.3.][1] discusses the combined circuit QZ = Q + beta * Z for some random beta. beta is
    /// chosen during proof generation, and so is not serialized. However the combined quad does
    /// impact the serialization format: because Q and Z are disjoint matrices, then any quad whose
    /// value is nonzero is understood to be part of Q, and any quad whose value is zero is
    /// understood to be part of Z.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    quads: Vec<Quad>,
}

impl Codec for CircuitLayer {
    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let logw = Size::decode(bytes)?;
        let num_wires = Size::decode(bytes)?;
        let num_quads = Size::decode(bytes)?;

        let mut prev_quad = None;
        let mut quads = Vec::with_capacity(num_quads.into());
        for _ in 0..num_quads.0 {
            let quad = Quad::decode(prev_quad, bytes)?;
            prev_quad = Some(quad);
            quads.push(quad);
        }

        Ok(Self {
            logw,
            num_wires,
            quads,
        })
    }

    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        self.logw.encode(bytes)?;
        self.num_wires.encode(bytes)?;
        Size::from(self.quads.len() as u32).encode(bytes)?;

        let mut prev_quad = None;
        for quad in &self.quads {
            quad.encode(prev_quad, bytes)?;
            prev_quad = Some(*quad);
        }

        Ok(())
    }
}

/// A quad describes an individual gate in the circuit, serialized according to struct Quad in [1]
/// and the ad-hoc definition in [2] and [3].
///
/// [2] and [3] implement a `struct Quad` which in turn contains a vector of `Quad::corner`. Each
/// `corner` value corresponds to the draft's `struct Quad`.
///
/// [1]: https://datatracker.ietf.org/doc/html/draft-google-cfrg-libzk-00#section-7.6
/// [2]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/proto/circuit.h
/// [3]: https://github.com/google/longfellow-zk/blob/87474f308020535e57a778a82394a14106f8be5b/lib/sumcheck/quad.h
#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]
pub struct Quad {
    /// The position of ths gate in its layer.
    gate_number: Size,
    /// Index of the left-hand wire feeding into this gate.
    left_wire: Size,
    /// Index of the right-hand wire feeding into this gate.
    right_wire: Size,
    /// Index into the circuit's constant table. The value at that index is the quad's value. If the
    /// value is 0, the quad is part of Z. If the value is nonzero, the quad is part of Q. See [1]
    /// for discussion of the combined quad.
    ///
    /// [1]: https://www.ietf.org/id/draft-google-cfrg-libzk-00.html#section-5.3.3
    const_table_index: Size,
}

impl Quad {
    /// Encode this quad as deltas relative to the previous quad in the circuit.
    // XXX extend [`crate::Codec`] to take an encoding parameter like prio::codec does so we can
    // pass in prev_quad
    fn encode(&self, prev_quad: Option<Quad>, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        self.gate_number
            .encode_delta(prev_quad.gate_number, bytes)?;
        self.left_wire.encode_delta(prev_quad.left_wire, bytes)?;
        self.right_wire.encode_delta(prev_quad.right_wire, bytes)?;
        self.const_table_index.encode(bytes)?;

        Ok(())
    }

    /// Encode this quad as deltas relative to the previous quad in the circuit.
    fn decode(prev_quad: Option<Quad>, bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        let prev_quad = prev_quad.unwrap_or_default();

        let gate_number = Size::decode_delta(prev_quad.gate_number, bytes)?;
        let left_wire = Size::decode_delta(prev_quad.left_wire, bytes)?;
        let right_wire = Size::decode_delta(prev_quad.right_wire, bytes)?;
        let const_table_index = Size::decode(bytes)?;

        Ok(Self {
            gate_number,
            left_wire,
            right_wire,
            const_table_index,
        })
    }
}

/// A serialized element of FieldP128.
///
/// TODO: convert this to and from [`crate::FieldP128`] so that we can do actual arithmetic in the
/// field. The derived [`ff::PrimeField`] trait gives us a nice convenient `from_u128` method, but
/// no convenient way to go back to u128 (just its generated Repr which is `[u8; 24]`).
#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Default)]
pub struct SerializedFieldP128(u128);

impl Codec for SerializedFieldP128 {
    fn encode(&self, bytes: &mut Vec<u8>) -> Result<(), anyhow::Error> {
        bytes
            .write_u128::<LittleEndian>(self.0)
            .context("failed to write u128")
    }

    fn decode(bytes: &mut Cursor<&[u8]>) -> Result<Self, anyhow::Error> {
        Ok(Self(
            bytes
                .read_u128::<LittleEndian>()
                .context("failed to read u128")?,
        ))
    }
}

impl From<SerializedFieldP128> for FieldP128 {
    fn from(value: SerializedFieldP128) -> Self {
        FieldP128::from_u128(value.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde::Deserialize;
    use std::{fs::File, io::BufReader};

    #[derive(Debug, Clone, Deserialize)]
    struct CircuitTestVector {
        field: u32,
        serialized: String,
        depth: u32,
        quads: u32,
        _terms: u32,
    }

    #[test]
    fn codec_roundtrip_p128() {
        SerializedFieldP128(0xffffefffffffffffffffffffffffffff).roundtrip();
    }

    #[test]
    fn roundtrip_quad() {
        let quad = Quad {
            gate_number: Size(1),
            left_wire: Size(2),
            right_wire: Size(3),
            const_table_index: Size(4),
        };

        let next_quad = Quad {
            gate_number: Size(5),
            left_wire: Size(6),
            right_wire: Size(7),
            const_table_index: Size(8),
        };

        let mut encoded = Vec::new();
        quad.encode(None, &mut encoded).unwrap();
        let decoded = Quad::decode(None, &mut Cursor::new(&encoded)).unwrap();
        assert_eq!(quad, decoded);

        let mut next_encoded = Vec::new();
        next_quad.encode(Some(quad), &mut next_encoded).unwrap();
        let next_decoded = Quad::decode(Some(quad), &mut Cursor::new(&next_encoded)).unwrap();
        assert_eq!(next_quad, next_decoded);
    }

    fn decode_circuit_test_vector(test_vector_name: &'static str) -> (CircuitTestVector, Circuit) {
        let test_vector: CircuitTestVector = serde_json::from_reader(BufReader::new(
            File::open(format!("test-vectors/circuit/{test_vector_name}.json")).unwrap(),
        ))
        .unwrap();

        // We only support FieldId 6 right now
        assert_eq!(test_vector.field, 6);

        let circuit_bytes = hex::decode(&test_vector.serialized).unwrap();

        let mut cursor = Cursor::new(circuit_bytes.as_slice());
        let circuit = Circuit::decode(&mut cursor).unwrap();

        assert_eq!(
            cursor.position() as usize,
            circuit_bytes.len(),
            "bytes left over after parsing circuit"
        );

        (test_vector, circuit)
    }

    #[test]
    fn roundtrip_circuit_test_vector() {
        let (test_vector, circuit) =
            decode_circuit_test_vector("longfellow-87474f308020535e57a778a82394a14106f8be5b-1");

        // We only support FieldId 6 right now
        assert_eq!(test_vector.field, 6);

        // The test vector says "depth: 3" but the serialized struct indicates 2 layers. It's not
        // clear what exactly is meant by "depth" or num_layers.
        assert_eq!(Size::from(test_vector.depth - 1), circuit.num_layers);
        assert_eq!(test_vector.depth as usize - 1, circuit.layers.len());

        let mut quads_count = 0;
        for layer in &circuit.layers {
            for quad in &layer.quads {
                assert!(quad.left_wire < layer.num_wires);
                assert!(quad.right_wire < layer.num_wires);
                assert!(quad.const_table_index < circuit.constant_table.len());
                assert!(quad.gate_number < layer.quads.len());
            }

            quads_count += layer.quads.len();
        }
        assert_eq!(test_vector.quads as usize, quads_count);

        let mut encoded_again = Vec::new();
        circuit.encode(&mut encoded_again).unwrap();
        assert_eq!(hex::encode(encoded_again), test_vector.serialized);
    }

    #[test]
    fn evaluate_circuit_true() {
        let (_, circuit) =
            decode_circuit_test_vector("longfellow-87474f308020535e57a778a82394a14106f8be5b-1");

        // This circuit verifies that 2n = (s-2)m^2 - (s - 4)*m. For example, C(45, 5, 6) = 0.
        let evaluation = circuit.evaluate(&[45, 5, 6]).unwrap();

        // Output size should match circuit serialization and values should all be zero
        assert_eq!(circuit.num_outputs, evaluation.wires[0].len());
        for output in evaluation.outputs() {
            assert_eq!(*output, FieldP128::ZERO);
        }

        // The remaining wire layers should match wire counts claimed by circuit serialization
        for (circuit_layer, evaluation_layer) in
            circuit.layers.iter().zip(evaluation.wires[1..].iter())
        {
            assert_eq!(circuit_layer.num_wires, evaluation_layer.len());
        }
    }

    #[test]
    fn evaluate_circuit_false() {
        let (_, circuit) =
            decode_circuit_test_vector("longfellow-87474f308020535e57a778a82394a14106f8be5b-1");

        // Evaluate with other values. At least one output element should be nonzero.
        assert!(
            circuit
                .evaluate(&[45, 5, 7])
                .unwrap()
                .outputs()
                .iter()
                .any(|output| *output != FieldP128::ZERO)
        );
    }
}
